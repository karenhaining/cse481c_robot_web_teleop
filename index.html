<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<style>
  ul li { margin-bottom: 20px; list-style: none; }
  #camera { display: none; }
  #buttons { display: none; position: relative; left: 10px; top:-2000; }
  img#cameraImage { transform: rotate(90deg); position: relative; left: -250px; top: 300px;}
  #control_buttons{position: relative; left: 900px; top: -800px;}
  #arm_buttons{position: relative; left: 1400px; top: -2440px;}
</style>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hello-vinitha/roslibjs@ros2actionclient/build/roslib.min.js"></script>
<script type="text/javascript" type="text/javascript">
  // Connection to rocky

  let ros = new ROSLIB.Ros({
    //url: 'wss://hellorobotuw.live'
    url: 'ws://rocky.hcrlab.cs.washington.edu:9090'
  });

  // Holding place for the FollowJointTrajectory client
  /* 
0: "wrist_extension"
1: "joint_lift"
2: "joint_arm_l3"
3: "joint_arm_l2"
4: "joint_arm_l1"
5: "joint_arm_l0"
6: "joint_head_pan"
7: "joint_head_tilt"
8: "joint_wrist_yaw"
9: "joint_wrist_pitch"
10: "joint_wrist_roll"
11: "joint_gripper_finger_left"
12: "joint_gripper_finger_right" 
  */
  let trajectoryClient;
  let realTrajectoryClient;
  let poseModeClient;
  let navigationModeClient;
  let positionClient;
  let alignmentMathClient;
  let boardCalibTopic;
  let holderCalibTopic
  let boardOffsetTopic;
  let holderOffsetTopic;
  let jointState;
  let arucoMarkerArray;

  let poses = {};
  let offsets_from_center = 0;
  let first_row = 0;
  let accumulated_rotation = 0;
  let tabletop_offset = 0;
  let holder_offsets = 0;
  let holder_arm = 0;

  let queuedMovements = [];

  const JOINTNAMES = ["wrist_extension", "joint_lift", "joint_head_pan", "joint_head_tilt",
                     "joint_wrist_yaw", "joint_wrist_pitch", "joint_wrist_roll", "gripper_aperture"]
  const ROWLENGTH = 0.0190;
  const HOLDERWIDTH = 0.057
  const ROWONE = 0.427;
  const TABLETOP = 0.76313;
  const NEUTRAL_ELEV = 0.81;
  const HOLDERTOP = 0.75158;
  const COLUMNLENGTH = 0.023;
  const GRIPPER_OPEN = 0.050;
  const GRIPPER_PLACED = 0.040;
  const GRIPPER_HOLDING = 0.020;
  const OFFSET_FOR_BOARD_CENTERING = 1; // TODO: Measure and change this value
  const ROTATION_OFFSET = 0;//0.075;
  const PARK_DISTANCE = 1.02;
  const EPSILON = 0.001;

  // Create subscription to the camera video topic
  const subscribeToCameraVideo = () => {
    let cameraImage = document.getElementById("cameraImage");
    let topic = new ROSLIB.Topic({
        ros: ros,
        name: "/camera/color/image_raw/compressed",
        messageType: "sensor_msgs/CompressedImage",
    });
    topic.subscribe((message) => {
      cameraImage.src = "data:image/jpg;base64," + message.data;
    });
  };

  const subscribeToJointStates = () => {
    const jointStateTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/stretch/joint_states",
            messageType: "sensor_msgs/msg/JointState",
    });

    jointStateTopic.subscribe((message) => {
        jointState = message;
    });
  };

  const subscribeToActions = () => {
    const actionTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/stretch_controller/follow_joint_trajectory/_action/status",
            messageType: "action_msgs/msg/GoalStatusArray",
    });
    console.log("subscribing to actions")
    actionTopic.subscribe((message) => {console.log(message);
    if (message.status_list[message.status_list.length - 1].status == 4) {
      console.log("last completed");  
      queuedMovementsCallback();
    }
    });
  }

  const subscribeToArucoMarkerArray = () => {
    const ArucoMarkerArrayTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/aruco/marker_array",
            messageType: "visualization_msgs/msg/MarkerArray",
    });

    ArucoMarkerArrayTopic.subscribe((message) => {
        arucoMarkerArray = message;
    });
  };

  // Create a handle to the FollowJointTrajectory action
  const createTrajectoryClient = () => {
    trajectoryClient = new ROSLIB.ActionHandle({
      ros: ros,
      name: "/stretch_controller/follow_joint_trajectory",
      actionType: "control_msgs/action/FollowJointTrajectory",
    });
  };

  const createAlignmentMathClient = () => {
    alignmentMathClient = new ROSLIB.Service({
      ros: ros,
      name : '/get_calibration_data',
      serviceType : 'std_srvs/srv/Trigger'
    })
  }

  const createCalibrationPublishers = () => {
    boardCalibTopic = new ROSLIB.Topic({
      ros: ros,
      name: "/board_calibration_data",
      messageType: "std_msgs/msg/Float64"
    });

    holderCalibTopic = new ROSLIB.Topic({
      ros: ros,
      name: "/holder_calibration_data",
      messageType: "std_msgs/msg/Float64"
    });

    boardOffsetTopic = new ROSLIB.Topic({
      ros: ros,
      name: "/board_offset_changes",
      messageType: "std_msgs/msg/Float64"
    });

    holderOffsetTopic = new ROSLIB.Topic({
      ros: ros,
      name: "/holder_offset_changes",
      messageType: "std_msgs/msg/Float64"
    });
  }

  const createNavigationModeClient = () => {
    navigationModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_navigation_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };
  const createPositionModeClient = () => {
    poseModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_position_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const createPositionClient = () => {
    positionClient = new ROSLIB.Service({
      ros: ros,
      name : '/get_joint_states',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const switchToPosition = () => {
    let request = new ROSLIB.ServiceRequest({})

    poseModeClient.callService(request, () => {console.log("In position mode")});
  };

  const switchToNavigation = () => {
    let request = new ROSLIB.ServiceRequest({});

    navigationModeClient.callService(request, () => {console.log("In navigation mode")});
  };

  const getPositions = () => {
    let request = new ROSLIB.ServiceRequest({});
    let output = {};
    let pos = positionClient.callService(request, (result) => {console.log("output is:"); console.log(result); output = result;});
    return output;
  };


  const savePosition = (name) => {
    let positions = jointState['position'];
    let gripper_aperture = positions[12] / 3;  // TODO: These values *seem* correct, but it's guesswork.
    back = positions.slice(6, 11);
    front = positions.slice(0, 2);
    positions = front.concat(back)
    positions.push(gripper_aperture);
    console.log("saved position: " + positions)
    
    poses[name] = positions;
  };

  const loadAndMoveToPosition = (name) => {
    let positions = poses[name];
    console.log("loaded position: " + positions);
    executeFollowJointTrajectory(JOINTNAMES, positions);
  }

  // Execute a FollowJointTrajectory action for given joints
  // See valid joints here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L4-L20
  // and joint limits here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L304
  const executeFollowJointTrajectory = (jointNames, jointPositions, jointVelocities) => {
    let goal;
    if (jointVelocities == undefined) {
      goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: jointNames,
        points: [
          {
            positions: jointPositions,
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    }
    else {
      goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: jointNames,
        points: [
          {
            positions: jointPositions,
            velocities: jointVelocities,
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    }
    trajectoryClient.createClient(goal);
  };

  const savePositionName = () => {
    posname = document.getElementById('pos_name').value;
    savePosition(posname)
    addPositionNameAndButton(posname)
  }

  const addPositionNameAndButton = (name) => {
    // overall div
    const newDiv = document.createElement("div");
    newDiv.id = ("d" + name);

    // Play button
    const newButton = document.createElement("button");
    newButton.onclick = function(){loadAndMoveToPosition(name)}
    const newContent = document.createTextNode(name);
    newButton.appendChild(newContent);

    // Delete button
    const delButton = document.createElement("button");
    delButton.onclick = function(){deletePose(name)}
    const delContent = document.createTextNode("Delete pose");
    delButton.appendChild(delContent);

    // Order selector for multi-pose loader
    const newSel = document.createElement("select");
    newSel.className = "poseReplaySel";
    newSel.name = name;
    
    // "Do not use" option
    const dontuse = document.createElement("option");
    dontuse.value = "" + -1
    const optionText = document.createTextNode("Do not include pose in replay sequence");
    dontuse.appendChild(optionText);
    newSel.appendChild(dontuse);

    // break
    const newBr = document.createElement("br");

    var count = 1;
    for (var i in poses) {
      const option = document.createElement("option");
      option.value = "" + count;
      const optionText = document.createTextNode("" + count);
      option.appendChild(optionText);
    
      newSel.appendChild(option);
      count++;
    }

    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      const option = document.createElement("option");
      option.value = "" + count - 1;
      const optionText = document.createTextNode("" + count - 1);
      option.appendChild(optionText);
      selectors[i].appendChild(option);
    }

    const posesDiv = document.getElementById("saved_poses");
    newDiv.appendChild(newButton);
    newDiv.appendChild(newSel);
    newDiv.appendChild(delButton);
    newDiv.appendChild(newBr);
    posesDiv.appendChild(newDiv);
  }

  const clearPoses = () => {
    const node = document.getElementById("saved_poses")
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    poses = {};
  }

  const deletePose = (name) => {
    const node = document.getElementById("saved_poses");
    const children = node.childNodes;
    // find and remove the child from the site
    for (let i = 0; i < children.length; i++) {
      if (children[i].id == ("d" + name)) {
        node.removeChild(children[i]);
      }
    }
    // find and remove the child from the dict
    let dictLen = Object.keys(poses).length;
    delete poses[name];

    // delete the dictLen child option from the selectors
    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      selector = selectors[i];
      for (let j = 0; j <  selector.length; j++) {
        if (selector[j].value == dictLen) {
          selector.removeChild(selector[j]);
        }
      }
    }
  }

  const replayPoseSequence = () => {
    selectors = document.getElementsByClassName("poseReplaySel");
    poseReplay = {}
    let max = 0;
    for (let i = 0; i < selectors.length; i++) {
      if (selectors[i].value != -1) {
        let offset = 0;
        max = selectors[i].value + "." +  offset;
        while (poseReplay[max]) {
          offset++;
          max = selectors[i].value + "." +  offset;
        }
        poseReplay[max] = selectors[i].name;
      }
    }
    
    let keysList = Object.keys(poseReplay);
    keysList.sort();
    for (let i = 0; i < keysList.length; i++) {
      loadAndMoveToPosition(poseReplay[keysList[i]]);
      sleep(4000);
    }
  }

  function sleep(milliseconds) {
    var start = new Date().getTime();
    while (true) {
      if ((new Date().getTime() - start) > milliseconds){
        break;
      }
    }
  }

  const pickupTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_OPEN, NEUTRAL_ELEV],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_OPEN, HOLDERTOP],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING,HOLDERTOP
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING,NEUTRAL_ELEV
            ],
            time_from_start: { secs: 10, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const pickupTileFromHolder = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP+0.106],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.106],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.175
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const dropTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING , NEUTRAL_ELEV],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP + 0.015],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_PLACED, TABLETOP + 0.015],
            time_from_start: { secs: 7, nsecs: 0 },
          },
          {
            positions: [GRIPPER_PLACED, NEUTRAL_ELEV],
            time_from_start: { secs: 9, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  // Open the gripper using FollowJointTrajectory
  const openGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.071])
  };


  // Close the gripper using FollowJointTrajectory
  const closeGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [GRIPPER_HOLDING])
  };

  const GripperStuff = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.075])
  };

  const openGripperSlightly = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [GRIPPER_OPEN])
  };

  const rotateCounterclockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [-1.75])
  };

  const rotateClockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [1.75])
  };

  const levelGrippper = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [0])
  };

  const yawww = () => {
    executeFollowJointTrajectory(['joint_wrist_yaw'], [0])
  };

  const yawwwRIGHT = () => {
    executeFollowJointTrajectory(['joint_wrist_yaw'], [Math.PI/2])
  };

  const levelPitch = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [0])
  };

  const PitchDown = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [-1.5])
  };

  const queuedMovementsCallback = () => {
    if (queuedMovements.length > 0) {
      let nextGoal = queuedMovements.shift()
      let goal = new ROSLIB.ActionGoal({
        trajectory: nextGoal
    });

       trajectoryClient.createClient(goal);
      }
  }

  const StowArm = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['wrist_extension', 'joint_lift'],
        points: [
        {
            positions: [0.05, NEUTRAL_ELEV + 0.1,],
          },
          
        ],
      },

    });

    queuedMovements.push(
      {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['wrist_extension', 'joint_lift'],
        points: [
        {
            positions: [0.05, NEUTRAL_ELEV + 0.11],
          },
          
        ],
      }
    )
    queuedMovements.push(
      {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['joint_wrist_pitch'],
        points: [
        {
            positions: [ -1.5],
          },
          
        ],
      }
    )

    queuedMovements.push(
      {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['wrist_extension', 'joint_lift',],
        points: [
        {
            positions: [0.05, NEUTRAL_ELEV - 0.3, ],
          },
          
        ],
      }
    )
    trajectoryClient.createClient(goal);
  }

  const DeployArm = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['wrist_extension', 'joint_lift'],
        points: [
        {
            positions: [0.05, NEUTRAL_ELEV + 0.11,]
          },
          
        ],
      },

    });

   
    queuedMovements.push(
      {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['joint_wrist_pitch'],
        points: [
        {
            positions: [0],
          },
          
        ],
      }
    )

    queuedMovements.push(
      {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['wrist_extension', 'joint_lift',],
        points: [
        {
            positions: [0.15, NEUTRAL_ELEV],
          },
          
        ],
      }
    )
        trajectoryClient.createClient(goal);

  }

  const moveLiftDownRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos - 0.05]);
  };

  const moveLiftDownRelativeTiny = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos - 0.005]);
  };

  const moveLiftUpRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos + 0.05]);
  };

  const moveCamera = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['joint_head_tilt', 'joint_head_pan'],
        points: [
        {
            positions: [-0.7 , -1.3],
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  }

const weirdTesting = () => {
  executeFollowJointTrajectory(['wrist_extension', 'joint_lift', 'joint_wrist_pitch'], [0.05, NEUTRAL_ELEV + 0.1, 0.0])
}

  // Move base forward
  const moveBaseForward = () => {
    offsets_from_center += 0.1
        holder_offsets += 0.1

    publishBoardOffsetDelta(0.1);
    publishHolderOffsetDelta(0.1);
    executeFollowJointTrajectory(['translate_mobile_base'], [0.1]);
  };

 const moveBaseForwardLots = () => {
    offsets_from_center += 0.15
        holder_offsets += 0.15

    publishBoardOffsetDelta(0.15);
    publishHolderOffsetDelta(0.15);

    executeFollowJointTrajectory(['translate_mobile_base'], [0.15]);
  };

  const moveBaseBackwardLots = () => {
    offsets_from_center -= 0.15
        holder_offsets -= 0.15

        publishBoardOffsetDelta(-0.15);
    publishHolderOffsetDelta(-0.15);
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.15]);
  };

  const moveBaseForwardOneTile = () => {
    offsets_from_center += COLUMNLENGTH
        holder_offsets += COLUMNLENGTH

        publishBoardOffsetDelta(COLUMNLENGTH);
    publishHolderOffsetDelta(COLUMNLENGTH);
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH]);
  };
  const moveBaseForwardTiny = () => {
    offsets_from_center += COLUMNLENGTH/4
        holder_offsets += COLUMNLENGTH/4

        publishBoardOffsetDelta(COLUMNLENGTH/4);
    publishHolderOffsetDelta(COLUMNLENGTH/4);
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH/4]);
  };

  const moveBaseBackwardOneTile = () => {
    offsets_from_center -= COLUMNLENGTH
        holder_offsets -= COLUMNLENGTH

        publishBoardOffsetDelta(-1 * COLUMNLENGTH);
    publishHolderOffsetDelta(-1 * COLUMNLENGTH);
    executeFollowJointTrajectory(['translate_mobile_base'], [-1 * COLUMNLENGTH]);
  };

  const moveBaseBackwardMisaligned = () => {
    offsets_from_center -= 0.01
        holder_offsets -= 0.01

        publishBoardOffsetDelta(-0.01);
    publishHolderOffsetDelta(-0.01);
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.01]);
  };

  const logPositions = () => {
    console.log(jointState);
  };

  const logArucoMarkers = () => {
    console.log(arucoMarkerArray);
  };

  const moveArmBackwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos - ROWLENGTH]);
  };

  const moveArmAllTheWayBack = () => {
    executeFollowJointTrajectory(['wrist_extension'], [0.1], [0.04]);
  };

  const moveArmAllTheWayForwards = () => {
    executeFollowJointTrajectory(['wrist_extension'], [0.45], [0.04]);
  };

  const moveArmForwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos + ROWLENGTH]);
  };

  // Move base backward
  /*const moveBaseBackward = () => {
    offsets_from_center -= 0.1
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.1]);

  };*/

  const rotateHeadClockwiseTest = () => {
    executeFollowJointTrajectory(['joint_head_pan'], [-Math.PI / 2])
  };
  const rotateHeadDown = () => {
    executeFollowJointTrajectory(['joint_head_tilt'], [-0.55]);
  };

  const rotateHeadRelativeCounterclockwise = () => {
    let currPos = jointState['position'][6]
    executeFollowJointTrajectory(['joint_head_pan'], [currPos + 0.1])
  }

  const rotateHeadRelativeClockwise = () => {
    let currPos = jointState['position'][6]
    executeFollowJointTrajectory(['joint_head_pan'], [currPos - 0.1])
  }

  const alignToArucoMarker = (marker_ids) => {
    let RoTaTioNGoaL; // In Radians
    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids.length; j+= 1) {
        if (marker_ids[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
        marker_indices.push(i);
        }
      }
    }
    if (marker_indices.length == 0) {
      console.log('Could not find any markers');
      return;
    }
    let quaternions = [];
    for (let i = 0; i < marker_indices.length; i+= 1) {
      quaternions.push(arucoMarkerArray['markers'][marker_indices[i]]['pose']['orientation']);
    }
    console.log("Quaternions are ")
    console.log(quaternions)

    head_angle = jointState['position'][6]; // Assume this is radians

    let yaw = 0;
    for (let i = 0; i < quaternions.length; i += 1) {
      let quaternion = quaternions[i];
      yaw += Math.atan2(2 * (quaternion['w'] * quaternion['z'] + quaternion['x'] * quaternion['y']), 1 - 2 * (quaternion['y']*quaternion['y'] + quaternion['z']*quaternion['z']))
    }
    yaw = yaw / quaternions.length
    //yaw = yaw + Math.PI / 2;
    if (yaw > Math.PI * 2) {
      console.log("Big pie");
      yaw = yaw - 2 * Math.PI
    }
    RoTaTioNGoaL = head_angle - yaw;
    RoTaTioNGoaL = RoTaTioNGoaL - ROTATION_OFFSET
    //RoTaTioNGoaL = head_angle - yaw + (Math.PI/2);
    console.log('yaw is ' + yaw);
    console.log('Rotation Goal is' + RoTaTioNGoaL);
    executeFollowJointTrajectory(['rotate_mobile_base', 'joint_head_pan'], [RoTaTioNGoaL, -Math.PI / 2]);
    //executeFollowJointTrajectory(['joint_head_pan'], [-Math.PI / 2])
  }

  const parallelPark = (marker_id) => {
    let currPos = jointState['position'];
    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_index;
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      if (arucoMarkerArray['markers'][i]['id'] == marker_id) {
        console.log("Found marker at index " + i);
        marker_index = i;
        break;
      }
    }
    if (marker_index == undefined) {
      console.log('Could not find aruco marker with id ' + marker_id);
      return;
    }

    let markerPosition = arucoMarkerArray['markers'][marker_index]['pose']['position'];

    let driveDistance = markerPosition['z'] - PARK_DISTANCE;
    
    executeFollowJointTrajectory(['rotate_mobile_base'], [-Math.PI/2], [0.15]);

    sleep(15000);

    executeFollowJointTrajectory(['translate_mobile_base'], [driveDistance]);

    sleep(8000);

    executeFollowJointTrajectory(['rotate_mobile_base'], [Math.PI/2], [0.15]);
  }


  const driveToCenterOfBoard = (marker_ids_left, marker_ids_right) => {
    let currPos = jointState['position'];

    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices_left = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids_left.length; j+= 1) {
        if (marker_ids_left[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices_left.push(i);
        }
      }
    }

    let marker_indices_right = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids_right.length; j+= 1) {
        if (marker_ids_right[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices_right.push(i);
        }
      }
    }
    if (marker_indices_left.length == 0 || marker_indices_right.length == 0) {
      console.log('Could not find any markers for one of left or right');
      return;
    }

    let markerPositionAvg_right = 0
    for (let i = 0; i < marker_indices_right.length; i+= 1) {

      markerPositionAvg_right += arucoMarkerArray['markers'][marker_indices_right[i]]['pose']['position']['y'];

    }

    let markerPositionAvg_left = 0
    for (let i = 0; i < marker_indices_left.length; i+= 1) {

      markerPositionAvg_left += arucoMarkerArray['markers'][marker_indices_left[i]]['pose']['position']['y'];

    }

    markerPositionAvg_right = markerPositionAvg_right / marker_indices_right.length
    markerPositionAvg_left = markerPositionAvg_left / marker_indices_left.length
    let horizontalOffset = (markerPositionAvg_left + markerPositionAvg_right) / 2
    //horizontalOffset = -horizontalOffset
    executeFollowJointTrajectory(['translate_mobile_base',], [horizontalOffset]);
  }

  const reachToFurthestRow = (marker_ids) => {
    let currPos = jointState['position'];

    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids.length; j+= 1) {
        if (marker_ids[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices.push(i);
        }
      }
    }
    if (marker_indices.length == 0) {
      console.log('Could not find any markers');
      return;
    }

    let markerPositionAvg = 0;
    for (let i = 0; i < marker_indices.length; i+= 1) {
      markerPositionAvg += arucoMarkerArray['markers'][marker_indices[i]]['pose']['position']['z'];
    }

    let extend_target = markerPositionAvg / marker_indices.length;
    extend_target = extend_target - 0.60
    executeFollowJointTrajectory(['wrist_extension',], [extend_target]);
  }
  

  const alignAndParallelPark = (marker_id) => {
    for (let l = 0; l < 5; l+=1) {
    alignToArucoMarker(marker_id);
    sleep(2000)
    }

    sleep(8000);
    parallelPark(marker_id);

    sleep(10000);
    driveToCenterOfBoard(marker_id);
  }


  const RotateClockwiseTiny = () => {
    accumulated_rotation += -0.05
    executeFollowJointTrajectory(['rotate_mobile_base'], [-0.05])
  }

  const RotateCounterClockwiseTiny = () => {
    accumulated_rotation += 0.05
    executeFollowJointTrajectory(['rotate_mobile_base'], [0.05])
  }

  const moveArmForwardTiny = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos + 0.01])
  }

  const moveArmBackwardTiny = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos - 0.01])
  }


  const saveCalibration = () => {
    first_row = jointState['position'][0];
    offsets_from_center = 0;
    accumulated_rotation = 0;
    tabletop_offset = 0;
    publishBoardCalibration(first_row);
  }

  const saveHolderCalibration = () => {
    holder_arm = jointState['position'][0];
    holder_offsets = 0;
    publishHolderCalibration(holder_arm);
  }

  const outputCalibrations = () => {
    console.log("First row: " + first_row);
    console.log("Offset from center: " + offsets_from_center);
    console.log("Accumulated rotation: " + accumulated_rotation);
    console.log("Tabletop offset: " + tabletop_offset);
  }

  const moveGripperToTopRight = () => {
    let drive_target = -7 * COLUMNLENGTH - offsets_from_center
    offsets_from_center += drive_target
        holder_offsets += drive_target

    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [first_row, drive_target])
}

  const moveGripperToBottomLeft = () => {
    let drive_target = 7* COLUMNLENGTH - offsets_from_center
    offsets_from_center += drive_target;
        holder_offsets += drive_target;

    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [first_row - (14 * ROWLENGTH), drive_target])
  }

  const moveGripperToTarget = (row, column) => {
    if (row > 15 || row < 1) {
      console.log("Bad row");
      return;
    }
    if (column > 15 || column < 1) {
      console.log("bad column");
      return;
    }

    let wrist_target = first_row - (ROWLENGTH * (row - 1));
    let drive_target = (COLUMNLENGTH * (8 - column)) - offsets_from_center;
    offsets_from_center += drive_target
    holder_offsets += drive_target

    publishBoardOffsetDelta(drive_target);
    publishHolderOffsetDelta(drive_target);
    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [wrist_target, drive_target]);
  }

  const GetGrippertargetandmoveto = () => {
    let r = document.getElementById('row_num').value
    let c = document.getElementById('column_num').value

    moveGripperToTarget(r, c)
  }

  const MoveToHolderTarget = (target) => {
    let drive_target = (HOLDERWIDTH * (1 - target)) - holder_offsets;
        offsets_from_center += drive_target
    holder_offsets += drive_target
    publishBoardOffsetDelta(drive_target);
    publishHolderOffsetDelta(drive_target);
    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [holder_arm, drive_target]);
  }

  const GetHolderTargetAndMove = () => {
    let t = document.getElementById('holder_pos').value;
    MoveToHolderTarget(t);
  }

  const rotateBaseClockwiseNinety = () => {
    executeFollowJointTrajectory(['rotate_mobile_base'], [Math.PI/2])
  }

  const rotateBaseCounterclockwiseNinety = () => {
    executeFollowJointTrajectory(['rotate_mobile_base'], [-Math.PI/2])
  }

  const returnToCenter = () => {
    let old_offset = offsets_from_center
    holder_offsets -= old_offset
    offsets_from_center -= old_offset
    publishBoardOffsetDelta(old_offset);
    publishHolderOffsetDelta(old_offset);
    executeFollowJointTrajectory(['translate_mobile_base'], [-old_offset])
    
  }

  const returnToHolder = () => {
    let old_offset = holder_offsets
    holder_offsets -= old_offset
    offsets_from_center -= old_offset
    publishBoardOffsetDelta(old_offset);
    publishHolderOffsetDelta(old_offset);
    console.log("Moving " + -1*old_offset)
    executeFollowJointTrajectory(['translate_mobile_base'], [-old_offset])
    
  }


  const GetAndPlayLetter = () => {
    let r = document.getElementById('row_num').value
    let c = document.getElementById('column_num').value
    let t = document.getElementById('holder_pos').value;

    playWord([[t, r, c]])
  }



  const playWord = (commands) => {
    let startWrist = jointState['position'][0];
    let trajectoryPoints = []
    let cumulativeDelta = 0.0
    
    trajectoryPoints.push({
            positions: [GRIPPER_OPEN , NEUTRAL_ELEV, startWrist, 0.0001 ],
            time_from_start: { secs: 1, nsecs: 0 },
            velocities: [2.0, 0.02, 0.03, 0.08]
          });
    
    let secs = 2;

    for (let i = 0; i < 1; i+= 1) { // i < commands.length; i += 1) {
      let holdtargetyeah = commands[i][0]
      let drive_target = (HOLDERWIDTH * (1 - holdtargetyeah)) - holder_offsets;
      if (drive_target == 0.0) {
        drive_target = 0.0001;
      }
      offsets_from_center += drive_target;
      holder_offsets += drive_target;
      cumulativeDelta += drive_target;
      trajectoryPoints.push({
        positions: [GRIPPER_OPEN , NEUTRAL_ELEV, holder_arm, drive_target ],
            time_from_start: { secs: secs, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.08]
      })
      secs += 2;

      trajectoryPoints = trajectoryPoints.concat([
         {
            positions: [GRIPPER_OPEN, NEUTRAL_ELEV, holder_arm, 0.00001],
            time_from_start: { secs: secs, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_OPEN, HOLDERTOP, holder_arm, 0.00001],
            time_from_start: { secs: secs + 2, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_HOLDING, HOLDERTOP, holder_arm, 0.00001],
            time_from_start: { secs: secs + 6, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_HOLDING,NEUTRAL_ELEV, holder_arm, 0.00001],
            time_from_start: { secs: secs + 10, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
      ])
      secs += 10;

      let rowtarget = commands[i][1]
      let columntarget = commands[i][2]
      let wrist_target = first_row - (ROWLENGTH * (rowtarget - 1));
      let drive_target2 = (COLUMNLENGTH * (8 - columntarget)) - offsets_from_center;
      if (drive_target2 == 0.0) {
        drive_target2 = 0.0001
      }
      offsets_from_center += drive_target2;
      holder_offsets += drive_target2;
      cumulativeDelta += drive_target2

      trajectoryPoints.push({
        positions: [GRIPPER_HOLDING , NEUTRAL_ELEV, wrist_target, drive_target2],
            time_from_start: { secs: secs + 2, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.08]
      })

      secs += 2;

      trajectoryPoints = trajectoryPoints.concat([
        {
            positions: [GRIPPER_HOLDING , NEUTRAL_ELEV, wrist_target, 0.00001],
            time_from_start: { secs: secs + 2, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.0175, wrist_target, 0.00001],
            time_from_start: { secs: secs + 4, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_OPEN, TABLETOP+0.0175, wrist_target, 0.00001],
            time_from_start: { secs: secs + 7, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
          {
            positions: [GRIPPER_OPEN, NEUTRAL_ELEV, wrist_target, 0.00001],
            time_from_start: { secs: secs + 9, nsecs: 0 },
            velocities: [2.0, 0.02, 0.035, 0.06]
          },
        ])
      secs += 10;

    }
    let old_offset = offsets_from_center
    cumulativeDelta -= old_offset

    holder_offsets -= old_offset
    offsets_from_center -= old_offset
    trajectoryPoints.push({
      positions: [GRIPPER_OPEN, NEUTRAL_ELEV, 0.09, -old_offset],
            time_from_start: { secs: secs + 3, nsecs: 0 },
                        velocities: [2.0, 0.03, 0.035, 0.08]

    })

    console.log("Final trajectory points:")
    console.log(trajectoryPoints)

    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift', 'wrist_extension', 'translate_mobile_base'],
        points: trajectoryPoints
      },
    });

    trajectoryClient.createClient(goal);
    publishBoardOffsetDelta(cumulativeDelta);
    publishHolderOffsetDelta(cumulativeDelta);
  } 

  const action_queue = [];
  let lastPlayedAction = [-1, -1, -1];

  const queueWord = () => {
    // only queue a word if the action queue is not empty
    if (action_queue.length == 0) {

      // at the beginning of the queue, ready the arm
      action_queue.push([5, 0, 0]);

      // a word is entered as follows:
      // destination: row, column
      // direction: R or D
      // holder positions: series of numbers from 1-7, inclusive, or . to indicate no letter played

      // read the start destination of the word
      let r = parseInt(document.getElementById('row_num').value)
      let c = parseInt(document.getElementById('column_num').value)

      // read the direction of the word (downwards or rightwards)
      let direction = document.getElementById('direction').value

      // read the holder positions of the word
      let positions = document.getElementById('holder_positions').value

      console.log("QUEUEING:");
      console.log("Row: " + r);
      console.log("Column: " + c);
      console.log("Direction: " + direction);
      console.log("Positions: " + positions);

      // QUEUE FORMAT:
      // each element is a tuple [type, coord1, coord2]
      // type: if 0, stow. ignore other coords
      //       if 1, go to holder position defined in coord1
      //       if 2, go to board position defined as row = coord1, col = coord2
      //       if 3, pick up a tile (assumed to be over the holder)
      //       if 4, place a tile (assumed to be over the board)
      //       if 5, ready the arm

      // loop through the holder positions given 
      for (let char of positions) {
        // get the holder slot. remember it might be a '.' to indicate that 
        // the tile is already on the board there
        let slot = parseInt(char);

        // only add goals for picking up and placing a tile if we're not over a '.'
        if (!isNaN(slot)) {
          // move to the holder position
          action_queue.push([1, slot, 0])
          // pick up tile 
          action_queue.push([3, 0, 0])
          // move to the board location
          action_queue.push([2, r, c])
          // place tile
          action_queue.push([4, 0, 0])
        }
        // always increment the row/col
        if (direction == "D") {
          r++;
        } else {
          c++;
        }
      }
      // at the end of the queue, stow the arm to prepare for next round
      action_queue.push([0, 0, 0]);
    }
    console.log(action_queue);
  }

  const playNextQueuedAction = () => {
    // pop off the next action to play from the queue
    let action = action_queue.shift();

    playAction(action);

    // mark this action as our last played action
    lastPlayedAction = action;
  }

  const replayLastAction = () => {
    playAction(lastPlayedAction);
  }

  const playAction = (action) => {
    // figure out what we need to to based on the opcode
    switch (action[0]) {
      case 0: // stow the arm
        StowArm();
        break;
      case 1: // go to holder position
        MoveToHolderTarget(action[1]);
        break;
      case 2: // go to board position
        moveGripperToTarget(action[1], action[2]);
        break; 
      case 3: // pick up a tile
        pickupTile();
        break;
      case 4: // drop a tile
        dropTile();
        break;
      case 5: 
        DeployArm();
        break;
      default: // do nothing if this is an invalid opcode
        break;
    }
    console.log("Played action " + action);
  }

  // Called when the rosbridge websocket connection is successful
  ros.on('connection', function() {
    document.getElementById('connection').innerHTML = "Connected to Stretch.";
    document.getElementById('camera').style.display = "block";
    document.getElementById('buttons').style.display = "block";
    console.log('Connected to websocket server.');
  
    subscribeToCameraVideo();
    createTrajectoryClient();
    subscribeToActions();
    createPositionModeClient();
    createNavigationModeClient();
    createPositionClient();
    subscribeToJointStates();
    subscribeToArucoMarkerArray();
    createAlignmentMathClient();
    createCalibrationPublishers();
  });

  // Called when the rosbridge websocket connection is failed
  ros.on('error', function(error) {
    document.getElementById('connection').innerHTML = "Error connecting to Stretch (see console for details)";
    console.log('Error connecting to websocket server: ', error);
  });

  // Called when the rosbridge websocket connection is closed
  ros.on('close', function() {
    document.getElementById('connection').innerHTML = "Disconnected";
    document.getElementById('camera').style.display = "none";
    document.getElementById('connection').style.display = "none";
    console.log('Connection to websocket server closed.');
  });

  const loadCalibrationData = () => {

    let request = new ROSLIB.ServiceRequest({})
    let calibration;
    alignmentMathClient.callService(request, (response) => {calibration = response.message;
      calibration_array = calibration.split(" ");
    first_row = parseFloat(calibration_array[0]);
    offsets_from_center = parseFloat(calibration_array[1]);
    holder_arm = parseFloat(calibration_array[2]);
    holder_offsets = parseFloat(calibration_array[3]);
    });
  }

  const getCalibrationData = () => {
    let request = new ROSLIB.ServiceRequest({})
    let calibration;
    alignmentMathClient.callService(request, (response) => {calibration = response.message});
    console.log(calibration);
    return calibration;
  }

  const publishBoardCalibration = (value) => {
    let msg = new ROSLIB.Message({
      data: value
    });
    boardCalibTopic.publish(msg);
  }

  const publishHolderCalibration = (value) => {
    let msg = new ROSLIB.Message({
      data: value
    });
    holderCalibTopic.publish(msg);
  }

  const publishBoardOffsetDelta = (delta) => {
    let msg = new ROSLIB.Message({
      data: delta
    });
    boardOffsetTopic.publish(msg);
  }

  const publishHolderOffsetDelta = (delta) => {
    let msg = new ROSLIB.Message({
      data: delta
    });
    holderOffsetTopic.publish(msg);
  }
</script>

<body>
  <h1>Crabble Interface v. 0.2</h1>
  <p id="connection">Connecting...</p>
  <div id="buttons">
    <p>Save poses here:</p>
    <ul>
      <li><p>Position name:</p></li>
      <li><input id="pos_name" name="Position name"></li>
      <li><button onClick="savePositionName()">Save position</button></li>
      <li><button onClick="clearPoses()">Clear saved positions</button></li>
    </ul>
    <p>Saved poses (click on the pose button to replay pose):</p>
  </div>
  <div id="saved_poses"></div>
  <button onClick="replayPoseSequence()">Replay selected positions in order</button>
  <div id="camera"><img id="cameraImage" /></div>
  <div id="control_buttons">
    <p>Column:</p>
    <select id="column_num" name="Column Number">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
      <option value="11">11</option>
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14">14</option>
      <option value="15">15</option>
    </select>
    <p>Row:</p>
    <select id="row_num" name="Row Number">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
      <option value="11">11</option>
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14">14</option>
      <option value="15">15</option>
    </select>
    <p>Direction:</p>
    <select id="direction" name="Direction">
      <option value="R">Right</option>
      <option value="D">Down</option>
    </select>
    <p>Holder Positions:</p>
    <input id="holder_positions" name="Position name">
    <br>
    <button onClick="queueWord()">Queue word</button>
    <button onClick="playNextQueuedAction()">Play next queued action</button>
    <button onClick="replayLastAction()">Replay last played action</button>
    <br/>
    <p>Nudge Buttons:</p>
    <button onClick="moveArmForwardOneTile()">Up</button>
    <button onClick="moveArmBackwardOneTile()">Down</button>
    <button onClick="moveBaseForwardOneTile()">Left</button>
    <button onClick="moveBaseBackwardOneTile()">Right</button>
    <br/>
    <br/>
    <br/>
    <br/>
    <button onClick="GetGrippertargetandmoveto()">Move to target</button>

    <p>Holder:</p>
    <select id="holder_pos" name="Holder Position">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
    </select>
    <br>
        <button onClick="GetHolderTargetAndMove()">Move to holder target</button>

    <br>
    <p>General Teleop Buttons:</p>
    <ul>
      <li><button onClick="GripperStuff()">Gripper Stuff</button></li>
      <li><button onClick="openGripper()">Open gripper</button></li>
      <li><button onClick="openGripperSlightly()">Open gripper slightly</button></li>
      <li><button onClick="closeGripper()">Close gripper</button></li>
      <li><button onClick="rotateClockwise()">Rotate gripper clockwise</button></li>
      <li><button onClick="rotateCounterclockwise()">Rotate gripper counterclockwise</button></li>
      <li><button onClick="levelGrippper()">Level gripper</button></li>
      <li><button onClick="levelPitch()">Flatten Pitch</button></li>
      <li><button onClick="PitchDown()">Pitch hand down</button></li>
      <li><button onClick="pickupTile()">Pickup Tile</button></li>
      <li><button onClick="pickupTileFromHolder()">Pickup Tile From Holder</button></li>
      <li><button onClick="dropTile()"> Drop tile</button></li>
      <li><button onClick="rotateHeadClockwiseTest()">Rotate head clockwise Test</button></li>
      <li><button onClick="rotateHeadRelativeCounterclockwise()">Rotate head counterclockwise relative</button></li>
      <li><button onClick="rotateHeadRelativeClockwise()">Rotate head clockwise relative</button></li>
      <li><button onClick="rotateHeadDown()">Look down</button></li>
      <li><button onClick="rotateBaseClockwiseNinety()">Rotate Base Clockwise Ninety Degrees</button></li>
      <li><button onClick="rotateBaseCounterclockwiseNinety()">Rotate Base Counterclockwise Ninety Degrees</button></li>
      <li><button onClick="RotateClockwiseTiny()">Rotate Base Clockwise</button></li>
      <li><button onClick="RotateCounterClockwiseTiny()">Rotate Base counterclockwise</button></li>
      <li><button onClick="moveBaseForwardOneTile()">Move base forward one tile</li>
        <li><button onClick="moveBaseForwardLots()">Move base forward a lot</li>
      <li><button onClick="moveBaseForwardTiny()">Move base forward a tiny bit</button></li>
      <li><button onClick="moveBaseBackwardOneTile()">Move base backward one tile</li>
                <li><button onClick="moveBaseBackwardLots()">Move base backwards a lot</li>

      <li><button onClick="moveBaseBackwardMisaligned()">Move base backward a tiny misaligned bit</button></li>
      <li><button onClick="logPositions()"> Output positions to console</button></li>
      <li><button onClick="logArucoMarkers()">Output aruco markers to console</button></li>
      <li><button onClick="outputCalibrations()">Output calibrations to console</button></li>
      <li><button onClick="moveLiftDownRelative()">Move lift down relative</button></li>
      <li><button onClick="moveLiftUpRelative()">Move lift up relative</button></li>
      <li><button onClick="moveLiftDownRelativeTiny()">Move lift down tiny</button></li>
      <li><button onClick="moveArmForwardOneTile()"> Move Arm Forward One Tile</button></li>
      <li><button onClick="moveArmBackwardOneTile()">Move Arm Backward One Tile</button></li>
      <li><button onClick="moveArmForwardTiny()"> Move Arm Forward Tiny</button></li>
      <li><button onClick="moveArmBackwardTiny()">Move Arm Backward Tiny</button></li>
      <li><button onClick="moveArmAllTheWayBack()">Move Arm all the way back</button></li>
            <li><button onClick="moveArmAllTheWayForwards()">Move Arm all the way Forwards</button></li>

      <li><button onClick="alignToArucoMarker([0, 1, 2, 3])">Align to Aruco</button></li>
      <li><button onClick="driveToCenterOfBoard([0, 2], [1, 3])">Drive to center of board</button></li>
      <li><button onClick="reachToFurthestRow([0, 1])">Reach to furthest row</button></li>
      <li><button onClick="parallelPark(0)">parallelPark</button></li>
      <li><button onClick="yawww()">Yawww</button></li>
      <li><button onClick="yawwwRIGHT()">Yawww RIGHT</button></li>
      <li><button onClick="saveCalibration()"> Save Calibration For Board Center</button></li>
      <li><button onClick="saveHolderCalibration()"> Save Calibration for leftmost holder tile</button></li>
      <li><button onClick="moveGripperToTopRight()">Move Gripper to Top Right square</button></li>
      <li><button onClick="moveGripperToBottomLeft()"> Move Gripper to Bottom Left square</button></li>
      <li><button onClick="StowArm()"> Stow Arm</button></li>
      <li><button onClick="DeployArm()"> Deploy Arm</button></li>
      <li><button onClick="playWord([[3, 8, 9]])">Fuck you Naama</button></li>
      <li><button onClick="GetAndPlayLetter()"> Get and Play Letter</button></li>
      <li><button onClick="weirdTesting()"> Testing</button></li>
      <li><button onClick="returnToCenter()">Return to center of board</button></li>
            <li><button onClick="returnToHolder()">Return to leftmost holder slot</button></li>
            <li><button onClick="loadCalibrationData()">Load Calibration Data</button></li>

    </ul>
  </div>
</body>
</html>