<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<style>
  ul li { margin-bottom: 20px; list-style: none; }
  #camera { display: none; }
  #buttons { display: none; position: relative; left: 10px; top:-2000; }
  img#cameraImage { transform: rotate(90deg); position: relative; left: -250px; top: 300px;}
  #control_buttons{position: relative; left: 900px; top: -1040px;}
  #arm_buttons{position: relative; left: 1400px; top: -2440px;}
</style>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hello-vinitha/roslibjs@ros2actionclient/build/roslib.min.js"></script>
<script type="text/javascript" type="text/javascript">
  // Connection to rocky
  let ros = new ROSLIB.Ros({
    url: 'ws://rocky.hcrlab.cs.washington.edu:9090'
  });

  // Holding place for the FollowJointTrajectory client
  let trajectoryClient;
  let poseModeClient;
  let navigationModeClient;
  let positionClient;
  let jointState;
  let arucoMarkerArray;

  let poses = {};

  const JOINTNAMES = ["wrist_extension", "joint_lift", "joint_head_pan", "joint_head_tilt",
                     "joint_wrist_yaw", "joint_wrist_pitch", "joint_wrist_roll", "gripper_aperture"]
  const ROWLENGTH = 0.0244;
  const ROWONE = 0.427;
  const TABLETOP = 0.777;
  const COLUMNLENGTH = 0.023;
  const GRIPPER_HOLDING = 0.033;
  // Create subscription to the camera video topic
  const subscribeToCameraVideo = () => {
    let cameraImage = document.getElementById("cameraImage");
    let topic = new ROSLIB.Topic({
        ros: ros,
        name: "/camera/color/image_raw/compressed",
        messageType: "sensor_msgs/CompressedImage",
    });
    topic.subscribe((message) => {
      cameraImage.src = "data:image/jpg;base64," + message.data;
    });
  };

  const subscribeToJointStates = () => {
    const jointStateTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/stretch/joint_states",
            messageType: "sensor_msgs/msg/JointState",
    });

    jointStateTopic.subscribe((message) => {
        jointState = message;
    });
  };

  const subscribeToArucoMarkerArray = () => {
    const ArucoMarkerArrayTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/aruco/marker_array",
            messageType: "visualization_msgs/msg/MarkerArray",
    });

    ArucoMarkerArrayTopic.subscribe((message) => {
        arucoMarkerArray = message;
    });
  };

  // Create a handle to the FollowJointTrajectory action
  const createTrajectoryClient = () => {
    trajectoryClient = new ROSLIB.ActionHandle({
      ros: ros,
      name: "/stretch_controller/follow_joint_trajectory",
      actionType: "control_msgs/action/FollowJointTrajectory",
    });
  };

  const createNavigationModeClient = () => {
    navigationModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_navigation_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };
  const createPositionModeClient = () => {
    poseModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_position_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const createPositionClient = () => {
    positionClient = new ROSLIB.Service({
      ros: ros,
      name : '/get_joint_states',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const switchToPosition = () => {
    let request = new ROSLIB.ServiceRequest({})

    poseModeClient.callService(request, () => {console.log("In position mode")});
  };

  const switchToNavigation = () => {
    let request = new ROSLIB.ServiceRequest({});

    navigationModeClient.callService(request, () => {console.log("In navigation mode")});
  };

  const getPositions = () => {
    let request = new ROSLIB.ServiceRequest({});
    let output = {};
    let pos = positionClient.callService(request, (result) => {console.log("output is:"); console.log(result); output = result;});
    return output;
  };


  const savePosition = (name) => {
    let positions = jointState['position'];
    let gripper_aperture = positions[12] / 3;  // TODO: These values *seem* correct, but it's guesswork.
    back = positions.slice(6, 11);
    front = positions.slice(0, 2);
    positions = front.concat(back)
    positions.push(gripper_aperture);
    console.log("saved position: " + positions)
    
    poses[name] = positions;
  };

  const loadAndMoveToPosition = (name) => {
    let positions = poses[name];
    console.log("loaded position: " + positions);
    executeFollowJointTrajectory(JOINTNAMES, positions);
  }

  // Execute a FollowJointTrajectory action for given joints
  // See valid joints here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L4-L20
  // and joint limits here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L304
  const executeFollowJointTrajectory = (jointNames, jointPositions) => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: jointNames,
        points: [
          {
            positions: jointPositions,
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const savePositionName = () => {
    posname = document.getElementById('pos_name').value;
    savePosition(posname)
    addPositionNameAndButton(posname)
  }

  const addPositionNameAndButton = (name) => {
    // overall div
    const newDiv = document.createElement("div");
    newDiv.id = ("d" + name);

    // Play button
    const newButton = document.createElement("button");
    newButton.onclick = function(){loadAndMoveToPosition(name)}
    const newContent = document.createTextNode(name);
    newButton.appendChild(newContent);

    // Delete button
    const delButton = document.createElement("button");
    delButton.onclick = function(){deletePose(name)}
    const delContent = document.createTextNode("Delete pose");
    delButton.appendChild(delContent);

    // Order selector for multi-pose loader
    const newSel = document.createElement("select");
    newSel.className = "poseReplaySel";
    newSel.name = name;
    
    // "Do not use" option
    const dontuse = document.createElement("option");
    dontuse.value = "" + -1
    const optionText = document.createTextNode("Do not include pose in replay sequence");
    dontuse.appendChild(optionText);
    newSel.appendChild(dontuse);

    // break
    const newBr = document.createElement("br");

    var count = 1;
    for (var i in poses) {
      const option = document.createElement("option");
      option.value = "" + count;
      const optionText = document.createTextNode("" + count);
      option.appendChild(optionText);
    
      newSel.appendChild(option);
      count++;
    }

    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      const option = document.createElement("option");
      option.value = "" + count - 1;
      const optionText = document.createTextNode("" + count - 1);
      option.appendChild(optionText);
      selectors[i].appendChild(option);
    }

    const posesDiv = document.getElementById("saved_poses");
    newDiv.appendChild(newButton);
    newDiv.appendChild(newSel);
    newDiv.appendChild(delButton);
    newDiv.appendChild(newBr);
    posesDiv.appendChild(newDiv);
  }

  const clearPoses = () => {
    const node = document.getElementById("saved_poses")
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    poses = {};
  }

  const deletePose = (name) => {
    const node = document.getElementById("saved_poses");
    const children = node.childNodes;
    // find and remove the child from the site
    for (let i = 0; i < children.length; i++) {
      if (children[i].id == ("d" + name)) {
        node.removeChild(children[i]);
      }
    }
    // find and remove the child from the dict
    let dictLen = Object.keys(poses).length;
    delete poses[name];

    // delete the dictLen child option from the selectors
    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      selector = selectors[i];
      for (let j = 0; j <  selector.length; j++) {
        if (selector[j].value == dictLen) {
          selector.removeChild(selector[j]);
        }
      }
    }
  }

  const replayPoseSequence = () => {
    selectors = document.getElementsByClassName("poseReplaySel");
    poseReplay = {}
    let max = 0;
    for (let i = 0; i < selectors.length; i++) {
      if (selectors[i].value != -1) {
        let offset = 0;
        max = selectors[i].value + "." +  offset;
        while (poseReplay[max]) {
          offset++;
          max = selectors[i].value + "." +  offset;
        }
        poseReplay[max] = selectors[i].name;
      }
    }
    
    let keysList = Object.keys(poseReplay);
    keysList.sort();
    for (let i = 0; i < keysList.length; i++) {
      loadAndMoveToPosition(poseReplay[keysList[i]]);
      sleep(4000);
    }
  }

  function sleep(milliseconds) {
    var start = new Date().getTime();
    while (true) {
      if ((new Date().getTime() - start) > milliseconds){
        break;
      }
    }
  }

  const pickupTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP-0.02],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.15
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const pickupTileFromHolder = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP+0.106],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.106],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.175
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const dropTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING , TABLETOP-0.02],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 7, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP + 0.15],
            time_from_start: { secs: 9, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  // Open the gripper using FollowJointTrajectory
  const openGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.08])
  };

  // Close the gripper using FollowJointTrajectory
  const closeGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.02])
  };

  const rotateCounterclockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [-1.75])
  };

  const rotateClockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [1.75])
  };

  const levelGrippper = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [0])
  };

  const levelPitch = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [0])
  };

  const pitchFortyFive = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [-0.58])
  };

  const pitchForDropping = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [-0.75])
  };

  const pitchDownForDropFromHolder = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [-1.3]);
  }

  const moveArmToHolder = () => {
    executeFollowJointTrajectory(['wrist_extension'], [ROWONE-10.8 *ROWLENGTH]);
  }

  // Move the lift using FollowJointTrajectory
  const moveLiftToTop = () => {
    executeFollowJointTrajectory(['joint_lift'], [1.1]);
  };

  // Move the lift using FollowJointTrajectory
  const moveLiftToTableTop = () => {
    executeFollowJointTrajectory(['joint_lift'], [TABLETOP]);
  };

  const moveLiftToSlightlyAboveTableTop = () => {
    executeFollowJointTrajectory(['joint_lift'], [TABLETOP + 0.02]);
  };

  const moveLiftToSlightlyAboveTableTopWhilePitchedForHolderPickup = () => {
    executeFollowJointTrajectory(['joint_lift'], [TABLETOP + 0.108]);
  };

  const moveLiftToSlightlyAboveTableTopWhilePitchedFullyDownwardsOrWhenInOtherCircumstancesThatWouldGenerallyWantTheArmNotAsLow= () => {
    executeFollowJointTrajectory(['joint_lift'], [TABLETOP + 0.13]);
  };

  const moveLiftDownRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos - 0.05]);
  };

  const moveLiftUpRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos + 0.05]);
  };

  const moveCamera = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['joint_head_tilt', 'joint_head_pan'],
        points: [
        {
            positions: [-0.7 , -1.3],
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  }

  // Move base forward
  const moveBaseForward = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [0.1]);
  };

  const moveBaseForwardOneTile = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH]);
  };
  const moveBaseForwardTiny = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH/4]);
  };

  const moveBaseBackwardOneTile = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [-1 * COLUMNLENGTH]);
  };

  const moveBaseBackwardMisaligned = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.025]);
  };

  const switchModeNavigation = () => {
    switchToNavigation();
  };

  const switchModePosition = () => {
    switchToPosition();
  };

  const logPositions = () => {
    console.log(jointState);
  };

  const logArucoMarkers = () => {
    console.log(arucoMarkerArray);
  };

  const moveArmBackwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos - ROWLENGTH]);
  };

  const moveArmForwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos + ROWLENGTH]);
  };

  // Move base backward
  const moveBaseBackward = () => {
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.1]);
  };

  const rotateHeadClockwiseNinety = () => {
    executeFollowJointTrajectory(['joint_head_pan'], [-1.45]);
  };
  const rotateHeadDown = () => {
    executeFollowJointTrajectory(['joint_head_tilt'], [-0.55]);
  };

  const rotateHeadRelativeCounterclockwise = () => {
    let currPos = jointState['position'][6]
    executeFollowJointTrajectory(['joint_head_pan'], [currPos + 0.1])
  }

  

  // Called when the rosbridge websocket connection is successful
  ros.on('connection', function() {
    document.getElementById('connection').innerHTML = "Connected to Stretch.";
    document.getElementById('camera').style.display = "block";
    document.getElementById('buttons').style.display = "block";
    console.log('Connected to websocket server.');
  
    subscribeToCameraVideo();
    createTrajectoryClient();
    createPositionModeClient();
    createNavigationModeClient();
    createPositionClient();
    subscribeToJointStates();
    subscribeToArucoMarkerArray();
  });

  // Called when the rosbridge websocket connection is failed
  ros.on('error', function(error) {
    document.getElementById('connection').innerHTML = "Error connecting to Stretch (see console for details)";
    console.log('Error connecting to websocket server: ', error);
  });

  // Called when the rosbridge websocket connection is closed
  ros.on('close', function() {
    document.getElementById('connection').innerHTML = "Disconnected";
    document.getElementById('camera').style.display = "none";
    document.getElementById('connection').style.display = "none";
    console.log('Connection to websocket server closed.');
  });
</script>

<body>
  <h1>Crabble Interface v. 0.2</h1>
  <p id="connection">Connecting...</p>
  <div id="buttons">
    <p>Save poses here:</p>
    <ul>
      <li><p>Position name:</p></li>
      <li><input id="pos_name" name="Position name"></li>
      <li><button onClick="savePositionName()">Save position</button></li>
      <li><button onClick="clearPoses()">Clear saved positions</button></li>
    </ul>
    <p>Saved poses (click on the pose button to replay pose):</p>
  </div>
  <div id="saved_poses"></div>
  <button onClick="replayPoseSequence()">Replay selected positions in order</button>
  <div id="camera"><img id="cameraImage" /></div>
  <div id="control_buttons">
    <p>General Teleop Buttons:</p>
    <ul>
      <li><button onClick="openGripper()">Open gripper</button></li>
      <li><button onClick="closeGripper()">Close gripper</button></li>
      <li><button onClick="rotateClockwise()">Rotate gripper clockwise</button></li>
      <li><button onClick="rotateCounterclockwise()">Rotate gripper counterclockwise</button></li>
      <li><button onClick="levelGrippper()">Level gripper</button></li>
      <li><button onClick="levelPitch()">Flatten Pitch</button></li>
      <li><button onClick="pitchFortyFive()">Pitch down for holder pickup</button></li>
      <li><button onClick="pitchForDropping()">Pitch down for extra dropping</button></li>
      <li><button onClick="pitchDownForDropFromHolder()">Pitch down for drop from holder</button></li>
      <li><button onClick="pickupTile()">Pickup Tile</button></li>
      <li><button onClick="pickupTileFromHolder()">Pickup Tile From Holder</button></li>
      <li><button onClick="dropTile()"> Drop tile</button></li>
      <li><button onClick="rotateHeadClockwiseNinety()">Rotate head clockwise</button></li>
      <li><button onClick="rotateHeadRelativeCounterclockwise()">Rotate head counterclockwise relative</button></li>
      <li><button onClick="rotateHeadDown()">Look down</button></li>
      <li><button onClick="moveLiftToTop()">Move lift to top</button></li>
      <li><button onClick="moveLiftToTableTop()">Move lift to tabletop</button></li>
      <li><button onClick="moveLiftToSlightlyAboveTableTop()">Move Lift slightly above tabletop</button></li>
      <li><button onClick="moveLiftToSlightlyAboveTableTopWhilePitchedForHolderPickup()">Move Lift to Slightly above tabletop while pitched for holder pickup</button></li>
      <li><button onClick="moveLiftToSlightlyAboveTableTopWhilePitchedFullyDownwardsOrWhenInOtherCircumstancesThatWouldGenerallyWantTheArmNotAsLow()">Move slightly down y'know</button></li>
      <li><button onClick="moveBaseForwardOneTile()">Move base forward one tile</li>
      <li><button onClick="moveBaseForwardTiny()">Move base forward a tiny bit</button></li>
      <li><button onClick="moveBaseBackwardOneTile()">Move base backward one tile</li>
      <li><button onClick="moveBaseBackwardMisaligned()">Move base backward a tiny misaligned bit</button></li>
      <li><button onClick="moveArmToHolder()">Move Arm To Holder</button></li>
      <li><button onclick="switchModePosition()">Switch to Position Mode</button></li>
      <li><button onClick="switchModeNavigation()">Switch to navigation mode</button></li>
      <li><button onClick="logPositions()"> Output positions to console</button></li>
      <li><button onClick="logArucoMarkers()">Output aruco markers to console</button></li>
      <li><button onClick="moveLiftDownRelative()">Move lift down relative</button></li>
      <li><button onClick="moveLiftUpRelative()">Move lift up relative</button></li>
      <li><button onClick="moveArmForwardOneTile()"> Move Arm Forward One Tile</button></li>
      <li><button onClick="moveArmBackwardOneTile()">Move Arm Backward One Tile</button></li>
    </ul>
  </div>
</body>
</html>