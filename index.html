<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />

<style>
  ul li { margin-bottom: 20px; list-style: none; }
  #camera { display: none; }
  #buttons { display: none; position: relative; left: 10px; top:-2000; }
  img#cameraImage { transform: rotate(90deg); position: relative; left: -250px; top: 300px;}
  #control_buttons{position: relative; left: 900px; top: -400px;}
  #arm_buttons{position: relative; left: 1400px; top: -2440px;}
</style>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/hello-vinitha/roslibjs@ros2actionclient/build/roslib.min.js"></script>
<script type="text/javascript" type="text/javascript">
  // Connection to rocky

  let ros = new ROSLIB.Ros({
    url: 'ws://rocky.hcrlab.cs.washington.edu:9090'
  });

  // Holding place for the FollowJointTrajectory client
  /* 
0: "wrist_extension"
1: "joint_lift"
2: "joint_arm_l3"
3: "joint_arm_l2"
4: "joint_arm_l1"
5: "joint_arm_l0"
6: "joint_head_pan"
7: "joint_head_tilt"
8: "joint_wrist_yaw"
9: "joint_wrist_pitch"
10: "joint_wrist_roll"
11: "joint_gripper_finger_left"
12: "joint_gripper_finger_right" 
  */
  let trajectoryClient;
  let poseModeClient;
  let navigationModeClient;
  let positionClient;
  let jointState;
  let arucoMarkerArray;

  let poses = {};
  let offsets_from_center = 0;
  let first_row = 0;
  let accumulated_rotation = 0;
  let tabletop_offset = 0;

  const JOINTNAMES = ["wrist_extension", "joint_lift", "joint_head_pan", "joint_head_tilt",
                     "joint_wrist_yaw", "joint_wrist_pitch", "joint_wrist_roll", "gripper_aperture"]
  const ROWLENGTH = 0.0195;
  const ROWONE = 0.427;
  const TABLETOP = 0.777;
  const COLUMNLENGTH = 0.023;
  const GRIPPER_HOLDING = 0.033;
  const OFFSET_FOR_BOARD_CENTERING = 1; // TODO: Measure and change this value
  const ROTATION_OFFSET = 0;//0.075;
  const PARK_DISTANCE = 0.90;
  const EPSILON = 0.001;

  // Create subscription to the camera video topic
  const subscribeToCameraVideo = () => {
    let cameraImage = document.getElementById("cameraImage");
    let topic = new ROSLIB.Topic({
        ros: ros,
        name: "/camera/color/image_raw/compressed",
        messageType: "sensor_msgs/CompressedImage",
    });
    topic.subscribe((message) => {
      cameraImage.src = "data:image/jpg;base64," + message.data;
    });
  };

  const subscribeToJointStates = () => {
    const jointStateTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/stretch/joint_states",
            messageType: "sensor_msgs/msg/JointState",
    });

    jointStateTopic.subscribe((message) => {
        jointState = message;
    });
  };

  const subscribeToArucoMarkerArray = () => {
    const ArucoMarkerArrayTopic = new ROSLIB.Topic({
            ros: ros,
            name: "/aruco/marker_array",
            messageType: "visualization_msgs/msg/MarkerArray",
    });

    ArucoMarkerArrayTopic.subscribe((message) => {
        arucoMarkerArray = message;
    });
  };

  // Create a handle to the FollowJointTrajectory action
  const createTrajectoryClient = () => {
    trajectoryClient = new ROSLIB.ActionHandle({
      ros: ros,
      name: "/stretch_controller/follow_joint_trajectory",
      actionType: "control_msgs/action/FollowJointTrajectory",
    });
  };

  const createNavigationModeClient = () => {
    navigationModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_navigation_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };
  const createPositionModeClient = () => {
    poseModeClient = new ROSLIB.Service({
      ros: ros,
      name : '/switch_to_position_mode',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const createPositionClient = () => {
    positionClient = new ROSLIB.Service({
      ros: ros,
      name : '/get_joint_states',
      serviceType : 'std_srvs/srv/Trigger'
    })
  };

  const switchToPosition = () => {
    let request = new ROSLIB.ServiceRequest({})

    poseModeClient.callService(request, () => {console.log("In position mode")});
  };

  const switchToNavigation = () => {
    let request = new ROSLIB.ServiceRequest({});

    navigationModeClient.callService(request, () => {console.log("In navigation mode")});
  };

  const getPositions = () => {
    let request = new ROSLIB.ServiceRequest({});
    let output = {};
    let pos = positionClient.callService(request, (result) => {console.log("output is:"); console.log(result); output = result;});
    return output;
  };


  const savePosition = (name) => {
    let positions = jointState['position'];
    let gripper_aperture = positions[12] / 3;  // TODO: These values *seem* correct, but it's guesswork.
    back = positions.slice(6, 11);
    front = positions.slice(0, 2);
    positions = front.concat(back)
    positions.push(gripper_aperture);
    console.log("saved position: " + positions)
    
    poses[name] = positions;
  };

  const loadAndMoveToPosition = (name) => {
    let positions = poses[name];
    console.log("loaded position: " + positions);
    executeFollowJointTrajectory(JOINTNAMES, positions);
  }

  // Execute a FollowJointTrajectory action for given joints
  // See valid joints here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L4-L20
  // and joint limits here: https://github.com/hello-robot/stretch_web_teleop/blob/master/src/shared/util.tsx#L304
  const executeFollowJointTrajectory = (jointNames, jointPositions, jointVelocities) => {
    let goal;
    if (jointVelocities == undefined) {
      goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: jointNames,
        points: [
          {
            positions: jointPositions,
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    }
    else {
      goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: jointNames,
        points: [
          {
            positions: jointPositions,
            velocities: jointVelocities,
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    }
    trajectoryClient.createClient(goal);
  };

  const savePositionName = () => {
    posname = document.getElementById('pos_name').value;
    savePosition(posname)
    addPositionNameAndButton(posname)
  }

  const addPositionNameAndButton = (name) => {
    // overall div
    const newDiv = document.createElement("div");
    newDiv.id = ("d" + name);

    // Play button
    const newButton = document.createElement("button");
    newButton.onclick = function(){loadAndMoveToPosition(name)}
    const newContent = document.createTextNode(name);
    newButton.appendChild(newContent);

    // Delete button
    const delButton = document.createElement("button");
    delButton.onclick = function(){deletePose(name)}
    const delContent = document.createTextNode("Delete pose");
    delButton.appendChild(delContent);

    // Order selector for multi-pose loader
    const newSel = document.createElement("select");
    newSel.className = "poseReplaySel";
    newSel.name = name;
    
    // "Do not use" option
    const dontuse = document.createElement("option");
    dontuse.value = "" + -1
    const optionText = document.createTextNode("Do not include pose in replay sequence");
    dontuse.appendChild(optionText);
    newSel.appendChild(dontuse);

    // break
    const newBr = document.createElement("br");

    var count = 1;
    for (var i in poses) {
      const option = document.createElement("option");
      option.value = "" + count;
      const optionText = document.createTextNode("" + count);
      option.appendChild(optionText);
    
      newSel.appendChild(option);
      count++;
    }

    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      const option = document.createElement("option");
      option.value = "" + count - 1;
      const optionText = document.createTextNode("" + count - 1);
      option.appendChild(optionText);
      selectors[i].appendChild(option);
    }

    const posesDiv = document.getElementById("saved_poses");
    newDiv.appendChild(newButton);
    newDiv.appendChild(newSel);
    newDiv.appendChild(delButton);
    newDiv.appendChild(newBr);
    posesDiv.appendChild(newDiv);
  }

  const clearPoses = () => {
    const node = document.getElementById("saved_poses")
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    poses = {};
  }

  const deletePose = (name) => {
    const node = document.getElementById("saved_poses");
    const children = node.childNodes;
    // find and remove the child from the site
    for (let i = 0; i < children.length; i++) {
      if (children[i].id == ("d" + name)) {
        node.removeChild(children[i]);
      }
    }
    // find and remove the child from the dict
    let dictLen = Object.keys(poses).length;
    delete poses[name];

    // delete the dictLen child option from the selectors
    // add a new step option to all existing selectors
    selectors = document.getElementsByClassName("poseReplaySel")
    for (let i = 0; i < selectors.length; i++) {
      selector = selectors[i];
      for (let j = 0; j <  selector.length; j++) {
        if (selector[j].value == dictLen) {
          selector.removeChild(selector[j]);
        }
      }
    }
  }

  const replayPoseSequence = () => {
    selectors = document.getElementsByClassName("poseReplaySel");
    poseReplay = {}
    let max = 0;
    for (let i = 0; i < selectors.length; i++) {
      if (selectors[i].value != -1) {
        let offset = 0;
        max = selectors[i].value + "." +  offset;
        while (poseReplay[max]) {
          offset++;
          max = selectors[i].value + "." +  offset;
        }
        poseReplay[max] = selectors[i].name;
      }
    }
    
    let keysList = Object.keys(poseReplay);
    keysList.sort();
    for (let i = 0; i < keysList.length; i++) {
      loadAndMoveToPosition(poseReplay[keysList[i]]);
      sleep(4000);
    }
  }

  function sleep(milliseconds) {
    var start = new Date().getTime();
    while (true) {
      if ((new Date().getTime() - start) > milliseconds){
        break;
      }
    }
  }

  const pickupTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP-0.02],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.15
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const pickupTileFromHolder = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP+0.106],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.106],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP+0.175
            ],
            time_from_start: { secs: 7, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  const dropTile = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['gripper_aperture', 'joint_lift'],
        points: [
        {
            positions: [GRIPPER_HOLDING , TABLETOP-0.02],
            time_from_start: { secs: 1, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 4, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING, TABLETOP-0.02],
            time_from_start: { secs: 7, nsecs: 0 },
          },
          {
            positions: [GRIPPER_HOLDING + 0.01, TABLETOP + 0.15],
            time_from_start: { secs: 9, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  };

  // Open the gripper using FollowJointTrajectory
  const openGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.071])
  };


  // Close the gripper using FollowJointTrajectory
  const closeGripper = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.05])
  };

  const openGripperSlightly = () => {
    executeFollowJointTrajectory(['gripper_aperture'], [0.06])
  };

  const rotateCounterclockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [-1.75])
  };

  const rotateClockwise = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [1.75])
  };

  const levelGrippper = () => {
    executeFollowJointTrajectory(['joint_wrist_roll'], [0])
  };

  const yawww = () => {
    executeFollowJointTrajectory(['joint_wrist_yaw'], [0])
  };

  const yawwwRIGHT = () => {
    executeFollowJointTrajectory(['joint_wrist_yaw'], [Math.PI/2])
  };

  const levelPitch = () => {
    executeFollowJointTrajectory(['joint_wrist_pitch'], [0])
  };

  const moveLiftDownRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos - 0.05]);
  };

  const moveLiftDownRelativeTiny = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos - 0.005]);
  };

  const moveLiftUpRelative = () => {
    let currPos = jointState['position'][1];
    executeFollowJointTrajectory(['joint_lift'], [currPos + 0.05]);
  };

  const moveCamera = () => {
    let goal = new ROSLIB.ActionGoal({
      trajectory: {
        header: { stamp: { secs: 0, nsecs: 0 } },
        joint_names: ['joint_head_tilt', 'joint_head_pan'],
        points: [
        {
            positions: [-0.7 , -1.3],
            time_from_start: { secs: 1, nsecs: 0 },
          },
        ],
      },
    });
    trajectoryClient.createClient(goal);
  }

  // Move base forward
  const moveBaseForward = () => {
    offsets_from_center += 0.1
    executeFollowJointTrajectory(['translate_mobile_base'], [0.1]);
  };

  const moveBaseForwardOneTile = () => {
    offsets_from_center += COLUMNLENGTH
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH]);
  };
  const moveBaseForwardTiny = () => {
    offsets_from_center += COLUMNLENGTH/4
    executeFollowJointTrajectory(['translate_mobile_base'], [COLUMNLENGTH/4]);
  };

  const moveBaseBackwardOneTile = () => {
    offsets_from_center -= COLUMNLENGTH
    executeFollowJointTrajectory(['translate_mobile_base'], [-1 * COLUMNLENGTH]);
  };

  const moveBaseBackwardMisaligned = () => {
    offsets_from_center -= 0.025
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.025]);
  };

  const logPositions = () => {
    console.log(jointState);
  };

  const logArucoMarkers = () => {
    console.log(arucoMarkerArray);
  };

  const moveArmBackwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos - ROWLENGTH]);
  };

  const moveArmAllTheWayBack = () => {
    executeFollowJointTrajectory(['wrist_extension'], [0]);
  };

  const moveArmForwardOneTile = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos + ROWLENGTH]);
  };

  // Move base backward
  const moveBaseBackward = () => {
    offsets_from_center -= 0.1
    executeFollowJointTrajectory(['translate_mobile_base'], [-0.1]);

  };

  const rotateHeadClockwiseTest = () => {
    executeFollowJointTrajectory(['joint_head_pan'], [-Math.PI / 2])
  };
  const rotateHeadDown = () => {
    executeFollowJointTrajectory(['joint_head_tilt'], [-0.55]);
  };

  const rotateHeadRelativeCounterclockwise = () => {
    let currPos = jointState['position'][6]
    executeFollowJointTrajectory(['joint_head_pan'], [currPos + 0.1])
  }

  const rotateHeadRelativeClockwise = () => {
    let currPos = jointState['position'][6]
    executeFollowJointTrajectory(['joint_head_pan'], [currPos - 0.1])
  }

  const alignToArucoMarker = (marker_ids) => {
    let RoTaTioNGoaL; // In Radians
    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids.length; j+= 1) {
        if (marker_ids[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
        marker_indices.push(i);
        }
      }
    }
    if (marker_indices.length == 0) {
      console.log('Could not find any markers');
      return;
    }
    let quaternions = [];
    for (let i = 0; i < marker_indices.length; i+= 1) {
      quaternions.push(arucoMarkerArray['markers'][marker_indices[i]]['pose']['orientation']);
    }
    console.log("Quaternions are ")
    console.log(quaternions)

    head_angle = jointState['position'][6]; // Assume this is radians

    let yaw = 0;
    for (let i = 0; i < quaternions.length; i += 1) {
      let quaternion = quaternions[i];
      yaw += Math.atan2(2 * (quaternion['w'] * quaternion['z'] + quaternion['x'] * quaternion['y']), 1 - 2 * (quaternion['y']*quaternion['y'] + quaternion['z']*quaternion['z']))
    }
    yaw = yaw / quaternions.length
    //yaw = yaw + Math.PI / 2;
    if (yaw > Math.PI * 2) {
      console.log("Big pie");
      yaw = yaw - 2 * Math.PI
    }
    RoTaTioNGoaL = head_angle - yaw;
    RoTaTioNGoaL = RoTaTioNGoaL - ROTATION_OFFSET
    //RoTaTioNGoaL = head_angle - yaw + (Math.PI/2);
    console.log('yaw is ' + yaw);
    console.log('Rotation Goal is' + RoTaTioNGoaL);
    executeFollowJointTrajectory(['rotate_mobile_base', 'joint_head_pan'], [RoTaTioNGoaL, -Math.PI / 2]);
    //executeFollowJointTrajectory(['joint_head_pan'], [-Math.PI / 2])
  }

  const parallelPark = (marker_id) => {
    let currPos = jointState['position'];
    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_index;
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      if (arucoMarkerArray['markers'][i]['id'] == marker_id) {
        console.log("Found marker at index " + i);
        marker_index = i;
        break;
      }
    }
    if (marker_index == undefined) {
      console.log('Could not find aruco marker with id ' + marker_id);
      return;
    }

    let markerPosition = arucoMarkerArray['markers'][marker_index]['pose']['position'];

    let driveDistance = markerPosition['z'] - PARK_DISTANCE;
    
    executeFollowJointTrajectory(['rotate_mobile_base'], [-Math.PI/2], [0.15]);

    sleep(15000);

    executeFollowJointTrajectory(['translate_mobile_base'], [driveDistance]);

    sleep(8000);

    executeFollowJointTrajectory(['rotate_mobile_base'], [Math.PI/2], [0.15]);
  }


  const driveToCenterOfBoard = (marker_ids_left, marker_ids_right) => {
    let currPos = jointState['position'];

    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices_left = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids_left.length; j+= 1) {
        if (marker_ids_left[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices_left.push(i);
        }
      }
    }

    let marker_indices_right = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids_right.length; j+= 1) {
        if (marker_ids_right[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices_right.push(i);
        }
      }
    }
    if (marker_indices_left.length == 0 || marker_indices_right.length == 0) {
      console.log('Could not find any markers for one of left or right');
      return;
    }

    let markerPositionAvg_right = 0
    for (let i = 0; i < marker_indices_right.length; i+= 1) {

      markerPositionAvg_right += arucoMarkerArray['markers'][marker_indices_right[i]]['pose']['position']['y'];

    }

    let markerPositionAvg_left = 0
    for (let i = 0; i < marker_indices_left.length; i+= 1) {

      markerPositionAvg_left += arucoMarkerArray['markers'][marker_indices_left[i]]['pose']['position']['y'];

    }

    markerPositionAvg_right = markerPositionAvg_right / marker_indices_right.length
    markerPositionAvg_left = markerPositionAvg_left / marker_indices_left.length
    let horizontalOffset = (markerPositionAvg_left + markerPositionAvg_right) / 2
    //horizontalOffset = -horizontalOffset
    executeFollowJointTrajectory(['translate_mobile_base',], [horizontalOffset]);
  }

  const reachToFurthestRow = (marker_ids) => {
    let currPos = jointState['position'];

    if (arucoMarkerArray == undefined) {
      console.log('No aruco markers');
      return
    }
    let marker_indices = [];
    for (let i = 0; i < arucoMarkerArray['markers'].length; i += 1) {
      for (let j = 0; j < marker_ids.length; j+= 1) {
        if (marker_ids[j] == arucoMarkerArray['markers'][i]['id']) {
          console.log("Found marker at index " + i);
          marker_indices.push(i);
        }
      }
    }
    if (marker_indices.length == 0) {
      console.log('Could not find any markers');
      return;
    }

    let markerPositionAvg = 0;
    for (let i = 0; i < marker_indices.length; i+= 1) {
      markerPositionAvg += arucoMarkerArray['markers'][marker_indices[i]]['pose']['position']['z'];
    }

    let extend_target = markerPositionAvg / marker_indices.length;
    extend_target = extend_target - 0.60
    executeFollowJointTrajectory(['wrist_extension',], [extend_target]);
  }
  

  const alignAndParallelPark = (marker_id) => {
    for (let l = 0; l < 5; l+=1) {
    alignToArucoMarker(marker_id);
    sleep(2000)
    }

    sleep(8000);
    parallelPark(marker_id);

    sleep(10000);
    driveToCenterOfBoard(marker_id);
  }


  const RotateClockwiseTiny = () => {
    accumulated_rotation += -0.05
    executeFollowJointTrajectory(['rotate_mobile_base'], [-0.05])
  }

  const RotateCounterClockwiseTiny = () => {
    accumulated_rotation += 0.05
    executeFollowJointTrajectory(['rotate_mobile_base'], [0.05])
  }

  const moveArmForwardTiny = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos + 0.01])
  }

  const moveArmBackwardTiny = () => {
    let currPos = jointState['position'][0]
    executeFollowJointTrajectory(['wrist_extension'], [currPos - 0.01])
  }


  const saveCalibration = () => {
    first_row = jointState['position'][0];
    offsets_from_center = 0;
    accumulated_rotation = 0;
    tabletop_offset = 0;
  }

  const outputCalibrations = () => {
    console.log("First row: " + first_row);
    console.log("Offset from center: " + offsets_from_center);
    console.log("Accumulated rotation: " + accumulated_rotation);
    console.log("Tabletop offset: " + tabletop_offset);
  }

  const moveGripperToTopRight = () => {
    let drive_target = -7 * COLUMNLENGTH - offsets_from_center
    offsets_from_center += drive_target
    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [first_row, drive_target])
}

  const moveGripperToBottomLeft = () => {
    let drive_target = 7* COLUMNLENGTH - offsets_from_center
    offsets_from_center += drive_target
    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [first_row - (14 * ROWLENGTH), drive_target])
  }

  const moveGripperToTarget = (row, column) => {
    if (row > 15 || row < 1) {
      return
    }
    if (column > 15 || column < 1) {
      return
    }

    let wrist_target = first_row - (ROWLENGTH * (14 * (row - 1)));
    let drive_target = (COLUMNLENGTH * (8 - column)) - offsets_from_center;
    offsets_from_center += drive_target
    executeFollowJointTrajectory(['wrist_extension', 'translate_mobile_base'], [wrist_target, drive_target]);
  }

  const GetGrippertargetandmoveto = () => {
    let r = document.getElementById('row_num').value
    let c = document.getElementById('column_num').value

    moveGripperToTarget(r, c)
  }

  // Called when the rosbridge websocket connection is successful
  ros.on('connection', function() {
    document.getElementById('connection').innerHTML = "Connected to Stretch.";
    document.getElementById('camera').style.display = "block";
    document.getElementById('buttons').style.display = "block";
    console.log('Connected to websocket server.');
  
    subscribeToCameraVideo();
    createTrajectoryClient();
    createPositionModeClient();
    createNavigationModeClient();
    createPositionClient();
    subscribeToJointStates();
    subscribeToArucoMarkerArray();
  });

  // Called when the rosbridge websocket connection is failed
  ros.on('error', function(error) {
    document.getElementById('connection').innerHTML = "Error connecting to Stretch (see console for details)";
    console.log('Error connecting to websocket server: ', error);
  });

  // Called when the rosbridge websocket connection is closed
  ros.on('close', function() {
    document.getElementById('connection').innerHTML = "Disconnected";
    document.getElementById('camera').style.display = "none";
    document.getElementById('connection').style.display = "none";
    console.log('Connection to websocket server closed.');
  });
</script>

<body>
  <h1>Crabble Interface v. 0.2</h1>
  <p id="connection">Connecting...</p>
  <div id="buttons">
    <p>Save poses here:</p>
    <ul>
      <li><p>Position name:</p></li>
      <li><input id="pos_name" name="Position name"></li>
      <li><button onClick="savePositionName()">Save position</button></li>
      <li><button onClick="clearPoses()">Clear saved positions</button></li>
    </ul>
    <p>Saved poses (click on the pose button to replay pose):</p>
  </div>
  <div id="saved_poses"></div>
  <button onClick="replayPoseSequence()">Replay selected positions in order</button>
  <div id="camera"><img id="cameraImage" /></div>
  <div id="control_buttons">
    <p>Column:</p>
    <select id="column_num" name="Column Number">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
      <option value="11">11</option>
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14">14</option>
      <option value="15">15</option>
    </select>
    <p>Row:</p>
    <select id="row_num" name="Row Number">
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
      <option value="8">8</option>
      <option value="9">9</option>
      <option value="10">10</option>
      <option value="11">11</option>
      <option value="12">12</option>
      <option value="13">13</option>
      <option value="14">14</option>
      <option value="15">15</option>
    </select>
    <br>
    <br>
    <button onClick="GetGrippertargetandmoveto()">Move to target</button>
    <p>General Teleop Buttons:</p>
    <ul>
      <li><button onClick="openGripper()">Open gripper</button></li>
      <li><button onClick="openGripperSlightly()">Open gripper slightly</button></li>
      <li><button onClick="closeGripper()">Close gripper</button></li>
      <li><button onClick="rotateClockwise()">Rotate gripper clockwise</button></li>
      <li><button onClick="rotateCounterclockwise()">Rotate gripper counterclockwise</button></li>
      <li><button onClick="levelGrippper()">Level gripper</button></li>
      <li><button onClick="levelPitch()">Flatten Pitch</button></li>
      <li><button onClick="pickupTile()">Pickup Tile</button></li>
      <li><button onClick="pickupTileFromHolder()">Pickup Tile From Holder</button></li>
      <li><button onClick="dropTile()"> Drop tile</button></li>
      <li><button onClick="rotateHeadClockwiseTest()">Rotate head clockwise Test</button></li>
      <li><button onClick="rotateHeadRelativeCounterclockwise()">Rotate head counterclockwise relative</button></li>
      <li><button onClick="rotateHeadRelativeClockwise()">Rotate head clockwise relative</button></li>
      <li><button onClick="rotateHeadDown()">Look down</button></li>
      <li><button onClick="RotateClockwiseTiny()">Rotate Base Clockwise</button></li>
      <li><button onClick="RotateCounterClockwiseTiny()">Rotate Base counterclockwise</button></li>
      <li><button onClick="moveBaseForwardOneTile()">Move base forward one tile</li>
      <li><button onClick="moveBaseForwardTiny()">Move base forward a tiny bit</button></li>
      <li><button onClick="moveBaseBackwardOneTile()">Move base backward one tile</li>
      <li><button onClick="moveBaseBackwardMisaligned()">Move base backward a tiny misaligned bit</button></li>
      <li><button onClick="logPositions()"> Output positions to console</button></li>
      <li><button onClick="logArucoMarkers()">Output aruco markers to console</button></li>
      <li><button onClick="outputCalibrations()">Output calibrations to console</button></li>
      <li><button onClick="moveLiftDownRelative()">Move lift down relative</button></li>
      <li><button onClick="moveLiftUpRelative()">Move lift up relative</button></li>
      <li><button onClick="moveLiftDownRelativeTiny()">Move lift down tiny</button></li>
      <li><button onClick="moveArmForwardOneTile()"> Move Arm Forward One Tile</button></li>
      <li><button onClick="moveArmBackwardOneTile()">Move Arm Backward One Tile</button></li>
      <li><button onClick="moveArmForwardTiny()"> Move Arm Forward Tiny</button></li>
      <li><button onClick="moveArmBackwardTiny()">Move Arm Backward Tiny</button></li>
      <li><button onClick="moveArmAllTheWayBack()">Move Arm all the way back</button></li>
      <li><button onClick="alignToArucoMarker([0, 1, 2, 3])">Align to Aruco</button></li>
      <li><button onClick="driveToCenterOfBoard([0, 2], [1, 3])">Drive to center of board</button></li>
      <li><button onClick="reachToFurthestRow([0, 1])">Reach to furthest row</button></li>
      <li><button onClick="parallelPark(0)">parallelPark</button></li>
      <li><button onClick="yawww()">Yawww</button></li>
      <li><button onClick="yawwwRIGHT()">Yawww RIGHT</button></li>
      <li><button onClick="saveCalibration()"> Save Calibration</button></li>
      <li><button onClick="moveGripperToTopRight()">Move Gripper to Top Right square</button></li>
      <li><button onClick="moveGripperToBottomLeft()"> Move Gripper to Bottom Left square</button></li>
      
    </ul>
  </div>
</body>
</html>